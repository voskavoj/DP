\chapter{Design}
\newcommand{\param}[1]{\texttt{\MakeUppercase{#1}}}
\newcommand{\variation}[1]{\paragraph{#1}}
\newcommand{\file}[1]{\paragraph{\texttt{#1}}}

The principal goal of this work is the experimental demonstration of SoP positioning using the satellite signals. This chapter describes the design and implementation of the navigation system, which performs SoP positioning using Iridium NEXT signals.

Iridium NEXT was chosen for the demonstration because of all the considered systems within the capability of the available radio equipment (i.e. Iridium NEXT, Orbcomm, Globalstar), Iridium NEXT is the best documented\footnote{This is a subjective claim gained from research and interactions with the amateur radio community. However, the number of results for the system name on Google Scholar illustrates the situation: \numlist{354000; 3800; 15600} respectively for "Iridium NEXT", "Orbcomm" and "Globalstar" as of April 2024}, the format of its frames is well known, has the most satellites and the most current constellation, its signals fall within the L1 band, which means readily available antennas and its channel structure is known and includes simplex broadcast channels of fixed frequency with unencrypted data.

In order to calculate the user position, the navigation system has to cover four steps, each of which is discussed in detail below:
\begin{enumerate}
    \item Signals from satellites are captured,
    \item data frames are extracted from the signal and decoded,
    \item decoded frames are processed - transmitting satellite is identified, the satellite position at the transmission time is calculated and frequency curves for individual satellites are found,
    \item initial location is estimated, and user position is calculated. 
\end{enumerate}

\paragraph{A note on nomenclature:} Since this chapter discusses the design of the navigation system in detail, an explanation of the used nomenclature should be given. Within the context of this chapter and the navigation system, the \textit{navigation system} refers to the application developed in this work and a \textit{frame} is a data unit sent over a channel by a communication satellite, on the reception of which the navigation system is based. \textit{Extracting} frames means acquiring information about a transmitted frame that do not go beyond its RF properties, such as centre frequency, signal strength or time of arrival. \textit{Demodulating} means converting captured samples into data bits, while \textit{decoding} means converting the bits into meaningful (and human-readable data). A frame has some properties, namely \textit{reception time} $t$, a \textit{centre frequency} $f$ which is shifted from a \textit{base frequency} of the channel $f_B$ on which the frame was transmitted by Doppler shift $f_D$ ($f_D = f - f_B$). Any value with the subscript $U$ refers to the user (i.e. the position of the antenna of the navigation system), a subscript $S$ or prefix \texttt{sat-} refers to the transmitting satellite. Unless otherwise noted, all positions denoted by $x, y, z$ are in ECEF frame (namely ITRS, the International Terrestrial Reference System) and all positions denoted by $\phi, \lambda, h$ are in the geodetic frame ($\phi, \lambda, h$ = latitude (rad), longitude (rad), height (m). In algorithms or conditions, subscript $i$ refers to the $i$-th received frame. References to \textit{Iridium}, unless noted otherwise, always mean \textit{Iridium NEXT}.


\section{Capturing signals}
The first step in determining the user position is to capture signals transmitted by the satellites used for navigation. To achieve that, an antenna and a radio are needed.

\subsection{Antenna setup}
As discussed in section \ref{s_sat_iridium_signals}, Iridium NEXT transmits in the \qtyrange{1626}{1626.5}{\MHz} frequency range, which lies within the L-band. The signal strength on Earth is expected to be in the \qtyrange{-90}{-110}{dBm} range\cite{sop01}, which is in the order of \unit{pW} in absolute signal power.

Thanks to the relative proximity (in frequency terms) of the Iridium signals to those of GPS, a GPS antenna can be used. However, some active antennas, such as the NovAtel GPS-702\cite{des03}, are severely attenuated in the Iridium signal band, and thus cannot be used.

The antenna used in this work is NovAtel GPS-704-X passive GNSS antenna. 
The 3 dB pass band of this antenna is \qtyrange{1.15}{1.65}{GHz} with minimum gain at zenith of \qty{+6.0}{dBic} in the L1 band. Additionally, the antenna features NovAtelâ€™s patented Pinwheel technology for multipath rejection and phase centre stability\cite{des04}. The antenna was chosen due to its suitable characteristics as well as its availability.

To acquire Iridium signals of sufficient strength, a low noise amplifier was found to be necessary. The amplifier used in this work is the Mini-Circuits ZX60-3018G-S coaxial amplifier with frequency range of \qtyrange{0.2}{3}{GHz}, typical maximum output power of \qty{+12.8}{dbm} and gain of \qty{20.60}{dB} for \qty{1671}{MHz}\footnote{Closest value in the datasheet.}\cite{des06}.

\subsection{Radio}
The radio used in the navigation system is the ADALM-PLUTO (in short PlutoSDR) software defined radio development kit. It is a portable self-contained RF-learning module, equipped the AD9363 RF Agile Transceiver. PlutoSDR has one TX and one RX channel with a RF range of \qtyrange{0.325}{3.8}{GHz}. The maximum bandwidth is \qty{20}{Mhz}. The SDR is powered and communicates through USB2.0 with drivers available in Windows and application programming interface (API) in, among others, C, C++ and Python. The APIs are implemented in several development platforms, notably Matlab and GNURadio (via SoapySDR). The reference clock of the SDR has a nominal frequency of \qty{40}{Mhz} and an accuracy of \num{\pm25e-6}\cite{des05}. The block diagram of the SDR is in figure \ref{f_des_pluto_block}.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{img/des_pluto_block.png}
    \caption{PlutoSDR block diagram\cite{des05}}
    \label{f_des_pluto_block}
\end{figure}

\subsubsection{Frequency offset and drift}
\label{s_des_offset_drift}
The synthesizer blocks that generate all data clocks, sample clocks, and local oscillators inside the PlutoSDR transceiver are supplied by a reference clock, which is external to the transceiver, but it is integrated in PlutoSDR and connected to pin \texttt{XTALN} of the transceiver (see fig. \ref{f_des_transciever_diag})\cite{des07}. Due to frequency conversion, any error in the frequency of the reference clock will be multiplied in actual measurements. Given the reference clock nominal frequency of \qty{40}{Mhz} is approximately 40x times lower than the measured band (\qty{\approx1600}{Mhz}), \qty{1}{Hz} offset in reference clock frequency will appear as \qty{-40}{Hz} shift in measured frequency.

\begin{figure}
    \centering
    \includegraphics[width=0.75\linewidth]{img/des_transciever_diag.PNG}
    \caption{AD9363 functional diagram\cite{des07}}
    \label{f_des_transciever_diag}
\end{figure}

Measurements of satellite signals showed that the reference clock of the PlutoSDR suffers from significant frequency offset, which varies with time. As a result, the measured signal frequency differs from actual received frequency by up to \qty{20}{kHz}. A significant cause of the change in the reference clock frequency are variations in temperature, both as a result of internal heating of the SDR components and outer environment changes, which cannot be avoided when measuring outdoors or over a long period of time.

An experiment was carried out, in which the PlutoSDR reference clock frequency was compared to a precise frequency generator (an atomic clock at the FEE CUT). After SDR startup, the reference clock frequency was \qty{39999729}{Hz} (nominal frequency  $f_N$ is \qty{40000000}{Hz} - a difference of \qty{-271}{Hz} or $\num{-6.8e-6} \times f_N$). After 20 minutes of operation, the reference clock frequency was  \qty{39999571}{Hz} (\qty{-429}{Hz} or $\num{-10.7e-6} \times f_N$). After this time, the frequency varied by \qty{\pm 50}{Hz}, but mostly stabilised. Any change in external environment, such as opening the laboratory window, caused significant variation in reference clock frequency.

As a result of this experiment, the PlutoSDR was covered in polystyrene case when measurements were taken, to somewhat stabilise its temperature. Additionally, the SDR was calibrated to account for some of the discrepancy in reference clock frequency, by setting the device to assume the reference clock frequency is \qty{39999571}{Hz}.

This experiment, as well as the satellite signal measurements shows the navigation system needs to account for frequency offset (henceforth referred to as just \textit{offset}) and the change of this offset (henceforth referred to as \textit{drift}) in its calculations. Without precise external frequency source, such as atomic clock (which is unfeasible) or a GPS-synchronised oscillator (which introduces a reliance on GNSS), precise measurements of absolute frequency are not possible. Using a better SDR with more precise or better temperature-compensated oscillator might help, but any system needs to handle unreliable frequency measurements by itself.

\subsection{Measurement setup}
For successful signal capture, the antenna needs to have a wide and mostly unobstructed field of view. Furthermore, the radio should be appropriately protected from rapid changes in environment temperature (such as wind), and adequate power supply must be provided to the radio.

An example of the measurement setup used in this work is photographed in figure \ref{f_des_meas_setup}. It consist of the GPS-704-X antenna with the amplifier (1), an antenna stand (an orange planting box with a bit of cardboard on top) (2), the PlutoSDR in polystyrene case (weighed down by nice rocks the author brought from Greece) (3), a \qty{12}{VDC} laboratory power supply (which is older than the author) (4) powering the amplifier, a Lenovo T440p laptop (5) running the measurement software and a power supply (a slightly rotten power outlet whose circuit breaker the author found after 30 minutes of searching in the \textit{basement}) (6). The measurement setup changed very little during the course of the work.

The view of the antenna is unobstructed above approximately \ang{15} of elevation, with the exception of north direction, which is slightly obstructed by a tree. However, as is apparent in the data, the field of view is overall satisfactory.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{img/des_meas_setup}
    \caption{Measurement setup}
    \label{f_des_meas_setup}
\end{figure}


\section{Frame extraction and decoding}
One of the methods of acquiring and tracking a satellite signal has been described in section \ref{s_pos_tracking_satellite}. However, that refers only to acquiring the signal itself and measuring its frequency. It is highly advantageous to also demodulate and decode the data within the signal. Firstly, some frame types are associated with a specific frequency or a range of frequencies, which greatly simplifies determining the frequency on which the frames were transmitted, and thus their Doppler shift. Secondly, some frame types contain satellite identifiers, which are useful for determining which satellite is transmitting. Thirdly, some frame types contain the position of the transmitting satellite, which may be used as an initial location.

Extracting, demodulating and decoding frames from satellite signal is a specialised task, which is beyond the scope of this work. Therefore, two already existing programs were used - \texttt{gr-iridium}\cite{des09} and \texttt{iridium-toolkit}\cite{des10}.

The \texttt{gr-iridium} package is a module for GNURadio, which handles capturing and demodulating frames sent by Iridium satellites. It works with generic SDRs and outputs decoded Iridium frames as text output in console. Provided it is supplied with proper configuration, the package works from command line and is Windows-compatible, with compiled binaries available in Conda package manager. It requires GNURadio 3.10. The principle of operation is described below.
 
The \texttt{iridium-toolkit} is a Python application capable of decoding demodulated Iridium frames captured by \texttt{gr-iridium}. It can work from command line, is Windows-compatible and does not require compilation nor it relies on GNURadio. It can decode the data in several types of Iridium frames by matching against a known message format.

Both of these packages have already been used in research, such as in \cite{sat08} to capture Iridium Ring Alert messages over a long time.

% \paragraph{A note on nomenclature:} In this context, \textit{extracting} frames means acquiring information about a transmitted frame that do not go beyond its RF properties, such as centre frequency, signal strength or time of arrival. \textit{Demodulating} means converting captured samples into data bits, while \textit{decoding} means converting the bits into meaningful (and human-readable data).

\subsubsection{Process used by \texttt{gr-iridium} to capture and decode Iridium frames}
Below is a description of the process the \texttt{gr-iridium} uses to capture and demodulate Iridium frames. Since the documentation of the package is sparse, the information below comes was inferred from code. References to specific sections of code are in footnotes where appropriate\footnote{The source code is available at \url{https://github.com/muccc/gr-iridium/blob/v1.0.0/}}.

The core of the package is a GNURadio flowgraph (see fig. \ref{f_des_gr_iridium_blocks}\footnote{The flowgraph was created by the author, it is not actually present in graphical form in the package}). Within this GNURadio environment, IQ samples are passed along the solid arrows into the blue nodes of the function blocks and Protocol Data Unit (PDU) messages are passed along the dotted arrows into the grey nodes. The process of extracting and demodulating frames is sequential - it starts in the \texttt{Soapy Custom Source} and ends in the \texttt{iridium\_frame\_printer}.

% command to ease citing of code in gr-iridium
%\newcommand{\grline}[2]{\footnote{gr-iridium v1.0.0: lib/#1\_impl.cc: line #2, available at \url{https://github.com/muccc/gr-iridium/blob/v1.0.0/lib/#1\_impl.cc\#L#2}}}
\newcommand{\grline}[2]{\footnote{gr-iridium/lib/#1\_impl.cc, line #2}}
\newcommand{\grlinetagger}[1]{\grline{iridium\_burst\_tagger}{#1}}
\newcommand{\grlinedownmix}[1]{\grline{burst\_downmix}{#1}}
\newcommand{\grlinedemod}[1]{\grline{iridium\_qpsk\_demod}{#1}}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{img/des_gr_iridium_blocks}
    \caption{\texttt{gr-iridium} flowgraph}
    \label{f_des_gr_iridium_blocks}
\end{figure}

The \textbf{\texttt{Soapy Custom Source}} block handles communication with the PlutoSDR. It sends out raw IQ samples for further processing.

The \textbf{\texttt{iridium\_burst\_tagger}} block identifies Iridium bursts in the captured data and "tags" them by creating metadata with references to burst start time (in terms of samples), magnitude, internal ID, centre frequency, rough carrier frequency offset (CFO) etc. First, the block squares the received signals twice\grlinetagger{527}. Then it performs FFT on the received samples with as fixed length window of the "Blackman-Harris" type (scaling factor \num{0.42}, equivalent noise bandwidth \num{1.72}\grlinetagger{133})\cite{des08}. After that it removes peaks around burst by the use of a burst mask, extracts the remaining peaks, updates the mask to match the new burst and passes the samples along with the tag to block output.

The \textbf{\texttt{tagged\_burst\_to\_pdu}} block reads the tags and uses them to pack the raw samples belonging to a burst with the metadata from the tag into a standardised message format (a PDU), which is then passed into block output.

The \textbf{\texttt{burst\_downmix}} operates on PDUs. For each PDU, it shifts the centre frequency by the rough estimate of CFO\grlinedownmix{804}, applies a low pass filter, and decimates the signal. Then it searches for start of the burst by analysing magnitude of the filtered signal. Then it searches for the unique BPSK synchronisation word in the frame (see section \ref{s_sat_iridium_signals} and fig. \ref{f_sat_iridium_freq_and_frame_structure} for signal structure details) to acquire a fine estimation of CFO\grlinedownmix{520}, which is again used to shift the signal. After that, the signal is filtered and a correlation function is used to find the start of the unique word and to determine the direction of the burst (uplink or downlink)\grlinedownmix{612}. Lastly, it determines the exact frame size, appends the PDU with the new information and passes it to the block output.

The \textbf{\texttt{iridium\_qpsk\_demod}} block demodulates the frame data. It decimates the signal to one sample per symbol, applies a PLL to remove remaining frequency or phase offset\grlinedemod{358}. Then it perform a QPSK demodulation, checks the unique word and passes the modified PDU to the block output.

The \textbf{\texttt{frame\_sorter}} block sorts the PDU by time of arrival (the processing is multi-threaded, time ordering is thus not assured), and the \textbf{\texttt{iridium\_frame\_printer}} block prints the block into console or a file.



\section{Data processing}
After the capture, demodulation and decoding of Iridium frames, some processing is needed to create data suitable for navigation calculation.


\subsection{Parsing frames}
Firstly, since the output of the \texttt{iridium-toolkit} is text, the output needs to be parsed. The output from \texttt{iridium-toolkit} if of the form (1) frame type (e.g. IRA = Iridium Ring Alert); (2) Unix timestamp of the start of the recording\footnote{In the setup in this work, this timestamp is incorrect}; (3) seconds from the start of the recording; (4) centre frequency of the frame; (5) demodulator confidence in percent;  (6) noise values for the frame; (7) frame data length; (8) direction of the frame (UP = uplink, DL = downlink); (9) frame-type-specific data. An example of a received frame is below.

\vspace{\parskip}
\noindent\begin{minipage}{\textwidth}
\begin{verbatim}
    1    2             3              4           5    6
    IRA: p-289693-e000 000025108.8066 1626314368  91%  -29.47|
                  7   8  9
    -090.82|30.79 107 DL sat:067 beam:27 xyz=(+1390,+0092, ...
\end{verbatim}
\end{minipage}
\vspace{\parskip}

The frame-type-specific data for some frame types, namely IRA (Iridium Ring Alert, see section \ref{s_sat_iridium_signals} for details) and IBC (a frame of the duplex channels), contain a satellite identifier, e.g. \texttt{sat:067}. However, this is a system internal ID - it is not public and has no relation whatsoever to the IDs published by NORAD. Additionally, IRA frames contain information about the satellite position in geodetic frame (\texttt{pos} in degrees latitude/longitude, \texttt{alt} in km), e.g.

\begin{verbatim}
    pos=(+38.82/+003.79) alt=797
\end{verbatim}

If the \texttt{alt} is high (generally above \qty{700}{km}), the position refers to the actual satellite, if it is low, the position refers to the location on Earth where the satellite beam is hitting the surface. Some nonsensical values were also observed and filtered out by only accepting frames with $\qty{700}{km} < \texttt{alt} < \qty{900}{km}$ where satellite position information was extracted. The latitude and longitude is given with two significant digits of precision, which, for the latitude of Prague corresponds to accuracy of \qtylist{1.11; 0.71}{km} respectively - not suitable for precise navigation. The process by which Iridium satellites calculate this position is not public, but it can be assumed it has similar errors as the SGP4 algorithm.

The final navigation system is capable of working with IRA and IBC frames. From these, the timestamps (2 and 3), frequency (4) and satellite ID (part of 9) are extracted for further usage where navigation is concerned, and also satellite position (part of 9) is extracted from IRA frames in other applications.

\subsection{Determining frame transmission frequency}
To calculate the Doppler shift of the received frames, it is necessary to identify the channel - and thus the channel base frequency -  on which the frame was transmitted. For IRA frames, this is simple - the transmission frequency of Ring Alert frames is set at \qty{1626.2708}{MHz}. 

For IBC (and other duplex channels), the transmitting channel can be identified by looking which of the known channel centre frequencies is the closest (in frequency space). The channel spacing, which is higher than the maximum Doppler shift for line-of-sight communication, assures that there will be one and only one fit. However, this approach proved not reliable, as higher Doppler shifts were encountered (even in simplex channels where identification is certain).

An additional identification mechanism was thus implemented, where the received frames were sorted by the satellite ID, and a the channel was selected by the above method while observing that the relative Doppler shift to the base frequency among the frames received from a single satellite should not change rapidly:

\begin{equation*}
    \frac{f_{D_i}}{f_{B_i}} \approx \frac{f_{D_{i-1}}}{f_{B_{i-1}}} 
\end{equation*}

However, this still did not prove sufficient and the incorrectly classified channels were a source of significant distortion. Therefore, while the capability remained in the system, the system uses only IRA frames for navigation.

To filer out frames received with erroneous frequency, a thresholding filter was applied ($f_T$ is the threshold of Doppler shift, equal to the channel spacing of $\approx\qty{41.7}{kHz}$):

\begin{equation*}
    f_{D_i} < f_T
\end{equation*}


\subsection{Identifying the transmitting satellite}
The satellite ID with an IRA or an IBC message identifies a satellite within the Iridium ecosystem. However, the rules by which an ID is assigned to a specific satellite are neither public nor apparent. Put simply, the ID within an Iridium frame has no relation to any other public ID of a satellite, such as those assigned by NORAD and used in TLEs. Additionally, as experiments have shown (see below), while NORAD IDs are constant in time, Iridium IDs are not. Therefore, to determine which Iridium frame ID corresponds to which NORAD ID, a mapping table needs to be constructed.

The creation of the mapping table (Iridium frame ID to NORAD ID) in this work takes advantage of the satellite position information contained within an IRA frame. This can be compared to the positions of all active Iridium satellites predicted by the SGP4 algorithm for the same time. The satellite with the closest predicted position to the position in the frame can be assumed to be the one that transmitted the frame. The algorithm (in pseudocode without vector optimisation) is in alg. \ref{a_des_satellite_id}, an example of the table is in tab. \ref{t_des_sat08_table}.

\begin{algorithm}
    \centering
    \begin{verbatim}
satellites = download TLEs for Iridium
frames = load decoded IRA frames
saved_distances = list
frame_ID = table

for frame in frames:
    parse (RX_time, frame_ID, frame_position) from frame

    for sat_ID in satellites:
        predicted_position = run SGP4 for sat_ID at RX_time
        distance = predicted_position - frame_position
        save distance and sat_ID into saved_distances

    closest_ID = find satellite_ID for 
                    minimum distance in saved_distances
    save closest_ID to frame_ID row in saved_IDs

for frame_ID in saved_IDs:
    most_common_ID = find most common ID in frame_ID row
    Iridium ID frame_ID is NORAD ID most_common_ID
    \end{verbatim}
    \caption{Iridium satellite identification}
    \label{a_des_satellite_id}
\end{algorithm}


This process is fairly computationally demanding and not completely error-free. However, when done over several hundred frames with a follow-up application of statistical methods, the satellites can be identified fairly certainly. Uncertainly identified satellites were filtered out by maintaining that the number of frames per satellite is larger than \param{MIN-FRAME-OCCURRENCE}.

\subsubsection{Using a large dataset for mapping IDs}
\label{s_des_sat08_id}
Assuming the frame IDs remain constantly attached to the same satellite, it would be advantageous to use a large dataset spanning several days or weeks to identify all of the satellites within the Iridium constellation. Such dataset can be found in \cite{sat08}. The data come from Doha, Quatar, and are split into two parts. The first part, which was used for this work, spans 30 days between August 12\textsuperscript{th} and September 10\textsuperscript{th}, 2020 and includes \num{2060289} IRA frames. An excerpt from the mapping table is in tab. \ref{t_des_sat08_table}.

However, a comparison of the table created from the large dataset to a table created from data measured as part of this work in March 2024 reveals the IDs are not in fact constant. Thus, an out-of-date, albeit large dataset cannot be used to create the table. Furthermore, some IDs were observed to change even during this work (Jan. to Mar. 2024). Therefore, a mapping table needs to be generated for each new data.

\begin{table}
    \centering
    \begin{tabular}{l|ll|ll|l}
       & \multicolumn{2}{l|}{Most common} & \multicolumn{2}{l|}{2\textsuperscript{nd} most common} & \\
IRA ID & NORAD ID & Count                 & NORAD ID & Count                                       & Confidence \\ \hline
036 & 122 &  8715 & 169 &   414 & 95\%     \\
038 & 113 &  8774 &     &       & 100\%     \\
039 & 148 &  7158 &     &       & 100\%     \\
040 & 153 &  7300 & 124 &   334 & 95\%     \\
... & ... & ... & ... & \\
069 & 136 &  8930 &     &       & 100\%     \\
071 & 167 &  9314 & 170 &   190 & 98\%     \\
072 & 173 &  9110 & 175 &    16 & 100\%     \\
073 & 133 &  8807 & 169 &   340 & 96\%     \\
... & ... & ... & ... & \\
104 & 116 &  8878 &     &       & 100\%     \\
107 & 142 &  7343 & 124 &   182 &  98\%     \\
109 & 130 &  8870 &     &       & 100\%     \\
110 & 114 &  9186 &     &       & 100\%     \\
    \end{tabular}
    \caption{Example of ID mapping table from large dataset}
    \label{t_des_sat08_table}
\end{table}

\begin{table}
    \centering
    \begin{tabular}{l|lll}
       & \multicolumn{3}{c}{NORAD ID}  \\
IRA ID & Aug./Sep. 2020 & Jan. 2024 & Mar. 2024 \\ \hline
046 & 158 & 156 & 156 \\
049 & 163 & 159 & 159 \\
057 & 119 & \textbf{169} & \textbf{139} \\
... & ... & ... & ... \\
073 & 133 & 100 & 100 \\
078 & 107 & \textbf{179} & \textbf{128} \\
079 & 100 & 129 & 129 \\
    \end{tabular}
    \caption{Example of ID mapping table changing in time}
    \label{t_des_sat08_to_now_table}
\end{table}


\subsection{Identifying a satellite without decoding frames}
Not all frame types include satellite position information or a satellite ID. Furthermore, not all satellite constellations transmit readily decodable signals in the first place. Thus, a mechanism for satellite identification without relying on frame decoding is needed.

One such mechanism (see alg. \ref{a_des_satellite_id_gen} is based on selecting satellites based on plausibility of Doppler shift. First, a rough user location needs to be known. Second, the constellation of the satellite needs to be determined. Thirdly, the channel needs to be identified to determine the Doppler shift. Then, the positions of all the satellites within the constellation are predicted using the SGP4 algorithm. Satellites with negative elevation angles, which cannot plausibly be received, are removed. For all the remaining satellites, the expected Doppler shift for a given channel is calculated. The satellite with the closest estimated Doppler shift is then selected. Note that because in this situation there is no way to distinguish frames belonging to one (albeit unknown) satellite, statistical methods cannot be used.

This method requires prior estimate of user location, therefore it cannot be used alone. On the other hand, it requires no demodulation or decoding, and is thus far more generic. It would be suitable for extending the navigation system to other constellations than Iridium, where the IRA-based method would provide the initial position estimate. Since the navigation system uses IRA frames, this method was not implemented.

\begin{algorithm}
    \centering
    \begin{verbatim}
user_position = estimate of user location
satellites = download TLEs for constellation
frame = load a received frame
parse (RX_time, doppler_frequency) from frame

for sat_ID in satellites:
    predicted_position = run SGP4 for sat_ID at RX_time
    elevation = calculate elevation for
                    predicted_position and user_position
    if elevation < 0:
        continue the loop with the next sat_ID
    sat_doppler_freq = calculate doppler shift for
                            predicted_position and user_position
    save sat_doppler_freq and sat_ID

closest_ID = find sat_ID for
        min(abs(sat_doppler_freq - doppler_frequency) in saved data
    \end{verbatim}
    \caption{Generic satellite identification}
    \label{a_des_satellite_id_gen}
\end{algorithm}


\subsection{Predicting satellite position}
The final step in the data processing for navigation is to predict the position and velocity vectors of the satellite that transmitted each frame. To do this, TLEs for the satellite need to be downloaded, a prediction algorithm run and the resulting vectors converted to a proper frame of reference. This process is also commonly used in other parts of the navigation system (e.g. for satellite identification).

Up-to-date TLEs can be downloaded e.g. from CelesTrak\cite{des11}. For this purpose, a script was written which first checks if up-to-date TLE files for a given constellation can be found locally from a previous download, and if not, downloads TLEs from the server. In either case, it parses the TLEs, calculates the age of the TLE and returns a dictionary. The script can be supplied with a path to a directory, in which case it loads the TLEs from there. In case data were collected but TLEs for them are no longer available, such as for the data from \cite{sat08}, a Special Request can be made on CelesTrak. The required TLEs are then sent by email. As these TLEs are packaged in files per-satellite rather than per-constellation, a  script was created which performs the conversion and automatically selects a most up-to-date TLE set for a given time.

For estimation of satellite position, the widely used SGP4 algorithm was selected (see section \ref{s_pos_tle_sgp4} for details). In Python, this algorithm (in the version from \cite{pos06}) was implemented e.g. in the \texttt{python-spg4} package\cite{des12}, which was used in this work. If provided with a Julian date or an array thereof, the algorithm returns an array of postion and velocity vectors in the TEME frame (see section \ref{s_pos_frames_of_ref}).

To convert from the TEME frame to ITRS (ECEF), as well as to handle all other frame-of-reference conversions, the package \texttt{astropy}\cite{des13} was used. This package was also used to handle operations with times and dates, such as converting Georgian dates to Julian dates.

Lastly, the data were packed into a two dimensional array for further calculations. The array is arranged so the "rows" (first index) are the data processed from frames, and the "columns" (second index) are

\begin{itemize}
    \item absolute time of frame reception (Unix time i.e. seconds),
    \item centre frequency of frame (Hz),
    \item base frequency of frame channel (Hz),
    \item NORAD satellite ID (-),
    \item (3x) ITRS position vector (x, y, z; m),
    \item (3x) ITRS velocity vector (x, y, z; \unit{\m\per\s}).
\end{itemize}



\section{Calculating user position}
For calculating the user position from the processed data, the Doppler-curve-fitting method was implemented (see \autoref{s_transit_nav_method} for theoretical basis). % todo label is wrong

In principle, the method attempts to find a state vector $\Vec{s}$, so that the variance function $F(c_M, c_E)$, where $c_M$ is the measured Doppler curve and $c_E$ is a trial Doppler curve based on $\Vec{s}$, is minimal. Simply, the method tries to estimate a state vector, whose corresponding Doppler curve provides the \textit{best} match for the measured Doppler curve. The form of the vector $\Vec{s}$, the specific variance function and the method of creating the trial Doppler curve $c_E$, as well as the implementation of the search are described in detail below.

\subsection{Estimating initial position}
There are several ways to estimate an initial position for the method. In testing, the navigation system was shown to successfully locate the user while the initial position was well over \qty{1000}{km} away from the final position, the estimate may thus be only very rough. On the other hand, different implementations of the method may require more precise estimate.

Firstly, external knowledge may be used, e.g. it the user knows they are in the Czech Republic, a geographic centre of CR may be used.

Secondly, the position of any received satellite may be used, as those can be assumed to be relatively close. As apparent in \autoref{f_des_exp05_sats_extent}, the satellites are generally located within \qty{2500}{km}, with the majority of captured frames coming from less than \qty{1000}{km} away. An average of the satellite positions can be used to obtain a better estimate (see figure). However, the reliability of this method depends on the field of view of the antenna being similar in all directions - if, for instance, the antenna is shielded from the north, the resultant position will be significantly shifted southward.

Thirdly, as described in \autoref{s_transit_nav_method}, the user is (in an ideal case) located on a line perpendicular to the satellite track, intersecting the satellite track at the position where the Doppler shift of the satellite signal is zero ($r_{f_D = 0}$). It follows that the position on the satellite track which is closest to the user is $r_{f_D = 0}$. Obtaining this position is straightforward as long as the measured Doppler curve for a given satellite passes through zero. The received data are split into curves per satellite and per channel, that is, a curve is formed by all observations with constant $f_B$ and satellite ID. Furthermore, curves with longer gap between two frames than \param{MAX-CURVE-GAP} seconds and split. This was necessary for very long captures, where a single satellite is captured on two or three passes. Finally, curves with fewer than \param{MIN-CURVE-LENGTH} frames are discarded. For each curve the point of $f_D = 0$ is interpolated. Positions from all successfully interpolated curves are then averaged to obtain the initial position estimate.

The navigation system in this work uses the third method, with the second method as backup if no curves were interpolated. % todo tohle ted neni pravda, ale je to dobry napad do kodu
For further navigation calculations, the curves are joined together again to form a single curve.


\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{img/des_exp05_sats_extent.png}
    \caption{Example of tracks of captured satellites}
    \label{f_des_exp05_sats_extent}
\end{figure}


\subsection{Trial Doppler curve generation}
The Doppler frequency observed by a static user of a frame transmitted by a dynamic satellite  is (see \autoref{e_pos_dopp_shift})

\begin{equation}
    \label{e_des_dopp_shift}
    f_D = \frac{1}{c}\dot\rho f_B
\end{equation}

where the range rate $\dot\rho$ can be expressed as

\begin{equation}
    \label{e_des_range_rate}
    \dot\rho_i = v_S \frac{r_S - r_U}{||r_S - r_U||_2}
\end{equation}

where the satellite and user position vectors, $r_S$ and $r_U$ respectively, as well as the satellite velocity vector $v_S$, are expressed in ECEF frame.

Additionally, as mentioned in \autoref{s_des_offset_drift}, the received frequency is shifted by some amount, which is not constant. This frequency shift is modelled as a constant offset $f_O$ (Hz) and time-variable drift.

Experimentation has showed that the drift is not linear nor it can be accurately modelled as a polynomial. However, it was also found that within a shorter time window of about \qty{30}{min}, the drift can be approximated linearly. As a result, the drift is modelled as $f_{drift} = \dot f_O$, where $\dot f_O$ is the rate of change of the offset (\unit{\hertz\per\s}).

Combining equations \ref{e_des_dopp_shift} and \ref{e_des_range_rate} with offset and drift yields


\begin{equation}
    \label{e_des_dopp_curve}
    f_D = \frac{1}{c} f_B v_S \frac{r_S - r_U}{||r_S - r_U||_2} + f_O + \dot f_O t
\end{equation}

Inputting into \autoref{e_des_dopp_curve} the time $t$, frequency $f_B$ and vectors $r_S$ and $v_S$ of each frame of the measured curve $C_M$ at the trial user position $r_U$ outputs the trial $C_T$ Doppler curve, where both curves are functions of frequency by time.  % todo rename in intro

Therefore, the navigation system needs to estimate the user position, the offset and the drift. For simplicity of algorithm debugging, and to ensure the user position estimate remains plausible (i.e. not beneath or high above Earth surface), the position is given in geodetic frame. The state vector is
\begin{equation*}
    \Vec{s} = (\phi_U, \lambda_U, h_U, f_O, \dot f_O)
\end{equation*}

\subsection{Variance}
To evaluate how good is the trial position $r_U$, the trial curve and the measured curve are compared. To do this, a variance function $F(C_M, C_T)$ which for two curves yields a scalar value representing their similarity is needed.

The variance function can take advantage of the fact that both $C_M$ and $C_T$ share the same time axis, i.e. both represent Doppler frequencies at the same times.

For this work, the variance function is given as the sum of squares of the differences in frequency of both curves, that is the coefficient of similarity of the two curves $e$ is given as

\begin{equation}
    e = \sum_{i=1}^n (C_{M_i} - C_{T_i})^2
\end{equation}
where $n$ is the length of the two curves. The lesser the $e$, the more similar the curves are.

The function which generates a trial curve for a given state vector $\Vec{s}$ and compares it to the measured curve in order to output the variance $e$ in in alg. \ref{a_des_check_trial_curve}.

\begin{algorithm}
    \centering
%-------------------------------------------------------------|
    \begin{verbatim}
def check_trial_curve(lat_u, lon_u, alt_u, off_u, dft_u, 
                      measured_data, r_s, v_s):                      
    curve_len = lenght measured_data
    # measured curve = [times, doppler_frequencies]
    measured_curve, f_B = extract from measured_data
    start_time = min(measured_curve[:, 0])
    c = 299 792 458 m/s  # speed of light
    
    trial_curve = empty array of shape (curve_len, 2)
    trial_curve[:, 0] = measured_curve[:, 0]  # copy time axis
    r_u = convert (lat_u, lon_u, alt_u) to ECEF

    # range rate (scalar mult. and norm are along asix 0)
    Ro_dot = v_s * (r_s - r_u) / ||r_s - r_u|| 
    # doppler frequency 
    f_D = Ro_dot * f_b / C  
    # drift - substract start of measurement
    f_dft = (trial_curve[:, 0] - start_time) * dft_u
    # trial curve = doppler frequency + offset + drift
    trial_curve[:, 1] = f_d + off_u + f_drift

    # Calculate variance
    var = sum((measured_curve[:, 1] - trial_curve[:, 1]) **2)
    
    return var
    \end{verbatim}
    \caption{Evaluation of trial Doppler curve}
    \label{a_des_check_trial_curve}
\end{algorithm}


\subsection{Searching for the variance function minimum}
Two approaches to find the variance function minimum, i.e. the best estimate of user position, were implemented. The first is iterative - it moves the trial user position in the direction with the best improvement in variance. The second is grid-search based - the algorithm searches through a matrix of possible state vectors and picks the one with the lowest variance.

The iterative algorithm is fairly fast and can converge even when the initial location is very far from the final estimate. On the other hand, it is theoretically prone to convergence into local minima. Conversely, the grid search algorithm is very slow and requires the initial estimate of the user position to be fairly close\footnote{While the algorithm can search an arbitrarily large area, it would take a \textit{very} long time}, however, it is resilient to local minima. In the final system, only the iterative algorithm was used.

\subsubsection{The iterative search}
The iterative-search algorithm takes a current best estimate of the trial state vector $\Vec{s_0}$ and calculates variance $e_0$. Then, for each member $\Vec{s_0}_k$ of the state vector $\Vec{s}$ (e.g. longitude or drift), it moves the trial state vector by a corresponding step $\Delta_k$ in both directions ($+\Delta_k$, $-\Delta_k$) and calculates variance ($e_{k+}$, $e_{k-}$), whilst keeping the other members of the state vector constant. Then it compares the new variances with the original one ($e_0$) to obtain the best direction $\delta_k$ in which to move the state vector:
\begin{equation*}
    \delta_k = \text{sign}(\max(0, e_0 - e_{k+}) - \max(0, e_0 - e_{k-}))
\end{equation*}

If $\delta_k \not = 0$, the variance decreased in one or both of the directions, and member $\Vec{s_1}_k$ of the state vector for the next iteration is thus modified by adding or subtracting the step $\Delta_k$. If $\delta_k = 0$, the member is kept constant, but the step size is decreased by $\dot\Delta$, down to step limit $\Delta_{k_{MIN}}$:

\begin{align*}
    \text{If } \delta_k \not &= 0: \\
        \Vec{s_1}_k &= \Vec{s_0}_k + \delta_k \dot \Delta_k \\
        \Delta_{k_1} &= \Delta_{k} \\
    \text{If } \delta_k &= 0: \\
        \Vec{s_1}_k &= \Vec{s_0}_k \\
        \Delta_{k_1} &= \min(\dot\Delta \cdot \Delta_k, \Delta_{k_{MIN}})
\end{align*}

Variable step size, where the $\delta_k$ is used as the coefficient for the step size instead of the $\dot\Delta$, was tried, but it was found that this creates an insignificant decrease in the number of iterations compared to problems related to overstepping. Thus, fixed step size was used.

After checking all members of the state vector, the algorithm continues in another iteration with $\Vec{s_0} = \Vec{s_1}$ and  $\Delta_k = \Delta_{k_1}$ for all $k$. The algorithm ends either when the number of iteration exceeds \param{iteration-limit}, or when it converges. The convergence criterion is all step sizes are at their respective limit and moving in no direction improves the variance:
\begin{equation*}
    \text{convergence} = \text{all}_k(\Delta_k = \Delta_{k_{MIN}}) \And \text{all}_k(\delta_k = 0)
\end{equation*}

Because the algorithm was shown to be prone to cycles, a cycle detector was implemented, which looks at the last two sets of $\delta_k$. If their member-wise sum equals the zero vector, a cycle is detected and the step size of all members with $\delta_k \not= 0$ is forcibly decreased.

The number of trial curve checks is a useful metric to evaluate the algorithm speed. The algorithm performs $n+1$ trial curve checks per iteration, where $n$ is the size of $\Vec{s}$. In testing, about \numrange{200}{400} iterations, therefore \numrange{1200}{1600} searches ($n = 6$), were most common.

While the algorithm is not protected against convergence into a local minimum, this was not observed during testing very often, and the local minima that were observed were within hundreds of meters of the global minimum showed by the grid search method (see below).


\subsubsection{The grid search}
The grid search algorithm performs the trial curve checking for a set of combinations of $\Vec{s}$ and picks the one with the lowest variance.n The process is then repeated $M$ times with decreasing grid spacing.

First, an $n$-dimensional grid, where $n$ is the length of the state vector $\Vec{s}$, is constructed. Each axis belongs to one member $k$ of the state vector, and contains $g_k$ values spaced apart by step $\Delta_{k_m}$ ($m \in M$), centred on $\Vec{s_0}_k$. Then, for each point of the grid, trial checking is performed. Finally, the lowest variance is found, and the corresponding values of state vector members of the grid point are as $\Vec{s_1}$.

Once the $\Vec{s_1}$ is found, $m$ is incremented and a new grid is constructed based on $\Vec{s_1}$ and $\Delta_{k_m}$, which is chosen so $\Delta{k_{m}} \approx \Delta_{k_{m-1}} / g_k$ - this way, the new grid fills one cell of the previous grid. Once the step sizes (and thus the resolutions) are sufficiently small, the search is completed.

The step sizes are fixed as parameters in the form of a list of size $M$. The grid size $g_k$ is fixed for each state vector member in all iterations. If the step size in a given iteration is set to zero, the member is considered fixed in the previous value.

The algorithm performs $M \cdot \Pi^n_1 g_k$ trial curve checks in total. If this algorithm was to be used on its own, a sufficiently large step in horizontal coordinate would have to be in the order of \qty{100}{km} for $g = 10$, and likewise for the other state vector members. Thus, a total of $5 \cdot (10 \cdot 10 \cdot 10 \cdot 5 \cdot 5) = \num{125000}$ was sometimes needed, making this approach very slow. On the other hand, convergence to the global minium is assured, as long as the the actual user position lays within the first (largest) grid, which places stricter requirements on the estimation of the initial position than the iterative method.

To aleviate this shortcoming, a variation was considered where, if the lowest variance for a given grid was located at the edge of the grid, the grid would be extended in that direction. As this algorithm ended up not being used on its own, this was not implemented.

One possible application for this algorithm is as a final step to the iterative search, which solves the problem of convergence into a local minimum close to the actual user position. However, as any meaningful search would still require \num{e4} trial curve checks, significantly slowing down the overall calculation, for no observed benefit, this was not used.


\section{Navigation system implementation and structure}
The navigation system is written in Python. This language was selected for four reasons. Firstly, it is widely used in Academia, it contains many scientific packages and supports all the functions required by this work. Secondly, Python supports GNURadio, which greatly enabled the signal processing part of this work. Thirdly, the author is a professional programmer working in Python, and is thus very familiar with the language. And finally, the author believes that Free and Open Source software should be the go-to choice for Academia, and writing the application in Python means that anybody can access it without financial burden.

The application is written in accordance with Python coding standard, makes use of Python packages for some operations and implements its own functions for others. The code is encapsulated, uses classes where appropriate and is documented. Version control software (Git) was used extensively in development.

The code of the navigation system is structured to enable operation which is independent of the specific satellite system being received. Data are passed between parts of the program in standardised structures and the navigation calculations are generic. Thus, the system should work with minimal changes (once the radio support is implemented) also on e.g. Orbcomm or Globalstar.

The organisation of the project is shown in \autoref{f_des_project_structure}

\begin{figure}
    \begin{framed}
        \raggedright
        \texttt{+---Data} - folder with saved data from measurements \\    
        \texttt{+---External} - folder for external packages, excluded in Git\\
        \texttt{|   +---iridium-toolkit} - the \texttt{iridium-toolkit} package source code\\
        \texttt{|---src} - navigation system source code\\
        \texttt{    +---app} - executable files\\
        \texttt{    |   +---data\_analysis} - data analysis and visualisation scripts\\
        \texttt{    |   +---development} - other scripts used in development\\
        \texttt{    +---config} - configuration files, parameters of algorithms etc.\\
        \texttt{    +---navigation} - data processing, algorithms for navigation\\
        \texttt{    +---radio   } - tools of processing frames for specific satellite constellations\\  
        \texttt{    +---satellites} - scripts working with satellites, TLEs and SGP4\\
        \texttt{    |---utils} - utilities for debugging, plotting and logging\\
    \end{framed}
    \caption{Navigation system project structure}
    \label{f_des_project_structure}
\end{figure}

\subsection{Additional tools created as part of this work}
Some additional tools were created to aid in analysis, development and testing of the navigation system created in this work. They all fit within the \texttt{/app} section.

\file{generate\_test\_data} This script creates simulated data, which was very useful in development of the navigation algorithms as well as in analysis of the frequency of the received frames. Plotting the received frames ($t, f$) against the simulated data shows most clearly the frequency offset and drift induced by the local SDR oscillator errors. The process of creation of the simulated data is essentially equal to the one used in trial curve checking (see \autoref{e_des_dopp_curve}), with preset position. Data points are generated for each satellite present in the measured data, in one second increments for the entire duration of the measured data. An elevation filter is applied to remove signals form satellites which rare beyond the horizon, and only signals with Doppler shift of less than \qty{\pm36}{kHz} are kept.

\file{predict\_satellite\_passes} This application predicts which satellites will be visible in the near future. It first provides a summary of all visible satellites, with exact times and azimuths of rise and fall and maximum elevation. Then it each \qty{2}{seconds} prints all the visible satellites right now, with azimuth and elevation. This was useful in the early stages of developing the system to capture the satellite signals.

\file{read\_time} This scripts handles time synchronisation on the PlutoSDR, as the device was shown to not keep time properly. It connects over serial port, logs in and sets the device time to current system time using the \texttt{date} command. This is done when the system time seconds counter changes, to achieve maximum accuracy (since the \texttt{date} command accepts only whole seconds).

\file{convert\_tles\_from\_special\_request} This is a simple script which converts TLE files from CelesTrak special request (one file per satellite with all TLEs for a given period) into the format used for current TLEs by CelesTrak (only one file containing one TLE set each per satellite). For each satellite, the closest TLE set for a given date and time was picked. This was useful for retroactive download of TLEs (when the author forgot to download them during data capture).

\file{find\_norad\_ids\_in\_sat08\_data} This script was used to identify all the satellites in the large dataset from \cite{sat08}, as described in \autoref{s_des_sat08_id}.

\file{noise\_analysis} This script was used to evaluate the noise resilience of the system. Gaussian noise of increasing intensity and mean value was added to simulated data and then the navigation algorithm was run, to get an idea about the influence of noise on the precision of the navigation system. The results are shown in \autoref{s_exp}.

\section{Summary}
The navigation system is a Python application capable of calculating the user position from received satellite signal, without any prior knowledge of the user position. It is built to be independent of the actual satellite system used to navigate, and to be used with generic SDR and antenna setup. However, support of only Iridium and PlutoSDR are actually implemented and verified.

First, the system receives, demodulates and decodes Iridium frames, using GNURadio with \texttt{gr-iridium} and the \texttt{iridium-toolkit} for the signal and frame processing.

Next, the navigation system processes the received frames. It identifies on which channel was a frame transmitted. It is capable of working with any channel type which includes satellite identifier, but only IRA frames were used in its final form. The system downloads up-to-date TLEs from the internet and uses them for SGP4-algorithm predictions. The system matches Iridium internal IDs with NORAD IDs, and predicts the position of the transmitting satellite at frame reception time.

Then, it uses the processed data to estimate the initial position for the navigation calculations. To do this, it interpolates the moment of zero-Doppler-shift for each Doppler curve, and places the initial estimate at the position where the moment occurs, averaged over all interpolated curves.

Finally, the system calculates the user position using the Doppler-curve-fitting method in the iterative search algorithm. For each trial position, variance of the measured and trial curves is calculated, and the increase or decrease of the variance in all directions is evaluated. The trial position is then moved by a set step in the direction of most variance decrease, until it no longer decreases in any directions or the iteration limit is exceeded.

The performance of the navigation system is examined in \autoref{s_exp}.
